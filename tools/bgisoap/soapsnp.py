# coding: utf-8
"""
Wrapper for SoapSnp command line tool.
Assembles the consensus sequence for the genome of a
newly sequenced individual based on the alignment of
raw sequencing reads on a known reference genome.
SNPs are then identified on the consensus sequence
through the comparison with the reference.
"""

import soapsnp
import optparse, os, sys, subprocess, tempfile, shutil
from galaxy import eggs
import pkg_resources;

pkg_resources.require("bx-python")
from bx.cookbook import doc_optparse
#from galaxy import util

def stop_err( msg ):
    sys.stderr.write('%s\n' % msg)
    sys.exit()

def __main__():
    #Parse Command Line
    parser = optparse.OptionParser()
    parser.add_option('', '--alignment', dest='alignment', help='Alignment of short reads to reference')
    parser.add_option('', '--refgenome', dest='refgenome', help='Reference Sequence in fasta format')
    parser.add_option('', '--qualityscore', dest='qualityscore',
        help='A character defining the quality score for a base call. FASTQ files generated by the Illumina base-calling pipeline use ‘@’ as 0. Some organisations use ‘!’ as 0.')
    parser.add_option('', '--gedc', dest='gedc', help='Global error dependency coefficient')
    parser.add_option('', '--pcr_coefficient', dest='pcr_coefficient', help='PCR error dependency coefficient')
    parser.add_option('', '--althom', dest='althom', help='Novel altHOM prior probability')
    parser.add_option('', '--het', dest='het', help='Novel HET prior probability')
    parser.add_option('', '--hetprior', dest='hetprior', help='Validated HET prior, if no allele frequency known')
    parser.add_option('', '--althomprior', dest='althomprior',
        help='Validated altHOM prior, if no allele frequency known')
    parser.add_option('', '--unvalidated_hetprior', dest='unvalidated_hetprior',
        help='Unvalidated HET prior, if no allele frequency known')
    parser.add_option('', '--unvalidated_althomrate', dest='unvalidated_althomrate',
        help='Unvalidated altHOM rate, if no allele frequency known')
    parser.add_option('', '--fastq_score', dest='fastq_score',
        help='Maximum FASTQ quality score')
    parser.add_option('', '--output_format', dest='output_format',
        help='0=Text; 1=GLFv2; 2=GPFv2')

    #Outputs
    parser.add_option('', '--output', dest='output', help='Consensus sequence')
    ( options, args ) = parser.parse_args()
    tmp_dir = tempfile.mkdtemp()
    try:
        # exit if input file empty
        if os.path.getsize(options.alignment) == 0:
            raise Exception, 'Initial file empty'

        command = 'soapsnp -i %s -d %s -z %s -g %s -g %s -r %s -e %s -a %s -b %s -j %s -j %s -Q %s -F %s -o %s' % (
            options.alignment, options.refgenome, options.qualityscore, options.gedc, options.pcr_coefficient,
            options.althom, options.het, options.hetprior, options.althomprior, options.unvalidated_hetprior,
            options.unvalidated_althomrate, options.fastq_score, options.output_format, options.output)

        # print command
        tmp = tempfile.NamedTemporaryFile(dir=tmp_dir).name
        # print tmp
        tmp_stderr = open(tmp, 'wb')
        proc = subprocess.Popen(args=command, shell=True, cwd=tmp_dir, stderr=tmp_stderr.fileno())
        returncode = proc.wait()
        tmp_stderr.close()

        # print os.path.getsize( tmp_sorted_aligns_file_name)

        # get stderr, allowing for case where it's very large
        tmp_stderr = open(tmp, 'rb')
        stderr = ''
        buffsize = 1048576
        try:
            while True:
                stderr += tmp_stderr.read(buffsize)
                if not stderr or len(stderr) % buffsize != 0:
                    break
        except OverflowError:
            pass
        tmp_stderr.close()
        if returncode != 0:
            raise Exception, stderr
            # exit if sorted BAM file empty
        if os.path.getsize(options.output) == 0:
            raise Exception, 'The output file empty'
    except Exception, e:
        #clean up temp files
        if os.path.exists(tmp_dir):
            shutil.rmtree(tmp_dir)
        stop_err('Error in running soapsnp from (%s), %s' % (options.alignment, str(e)))

    # Clean up temp files
    if os.path.exists(tmp_dir):
        shutil.rmtree(tmp_dir)
    # Check that there are results in the output file
    if os.path.getsize(options.output) > 0:
        sys.stdout.write('Running ended successfully!')
    else:
        stop_err('The output file is empty, there may be an error with your input file.')

if __name__ == "__main__": __main__()
